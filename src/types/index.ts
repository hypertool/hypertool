import { constants } from "../utils";

export interface IController {
  id: string;
  name: string;
  description: string;
  language: string;
  patched: string;
  status: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface IScreen {
  id: string;
  app: IApp;
  name: string;
  title: string;
  description: string;
  slug: string;
  content: string;
  controller: IController;
  status: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface IApp {
  id: string;
  name: string;
  title: string;
  slug: string;
  description: string;
  screens: IScreen[];
  status: string;
  createdAt: Date;
  updatedAt: Date;
}

export type TAppContext = IApp;

export interface ICraftNode {
  custom: {
    [key: string]: any;
  };
  nodes: string[];
  props: {
    [key: string]: any;
  };
  type: {
    resolvedName: string;
  };
  parent?: string;
}

export type TCraftNodeKey = keyof ICraftNode;

export type TBasicNodeType = "View" | "Fragment" | "Text";

export interface ISymbolReference {
  moduleId: string;
  target: string;
}

export type TPropertyValue =
  | number
  | boolean
  | string
  | null
  | object
  | ISymbolReference
  | undefined;

export interface IComponentProps extends Record<string, TPropertyValue> {
  id?: string;
}

export interface INode {
  /**
   * Each node has two identifiers: `node.internalId` and `node.props.id`.
   *
   * `node.internalId`:
   * It helps in internal bookkeeping of the nodes. It is mandatory, automatically
   * generated by CraftJS, and guaranteed to be unique across the screen.
   *
   * `node.props.id`:
   * It helps controllers select and apply actions on nodes. It is optional,
   * and assigned by the developer.
   *
   * Hypertool does not guarantee the prop ID to be unique across the screen.
   * It is the responsibility of the user to ensure the uniqueness.
   * App builder and generic host neither produce errors nor warnings for
   * duplicate prop IDs.
   */
  internalId: string;
  type: string | TBasicNodeType;
  children: INode[];
  props: IComponentProps;
  __hyperNode: true;
}

export interface IPatch {
  [key: string]: Record<string, TPropertyValue> | INode;
}

export interface IPath {
  /**
   * The path component in the URL, beginning with a `/`.
   */
  path: string;

  /**
   * The query string component in the URL, beginning with a `?`.
   */
  query: string;

  /**
   * A URL fragment identifier, beginning with a `#`.
   */
  hash: string;
}

/**
 * Describes a location that is the destination of some navigation.
 * It can either be a URL or pieces of a URL.
 */
export type TNavigationTarget = string | Partial<IPath>;

export type TQueryParams = Record<string, string | string[]>;

export type TQueryParamPair = [string, string];

export type TUpdateQueryParams =
  | string // "foo=bar&foo=soap"
  | TQueryParamPair[] // [["foo", "bar"], ["foo", "soap"]]
  | TQueryParams; // { foo: ["bar", "soap"] }

export interface ILocation extends IPath {
  /**
   * An object containing the decoded dynamic parameters from the
   * path component in the URL.
   */
  pathParams: Record<string, string | undefined>;

  /**
   * An object containing the decoded query parameters contained
   * in the URL.
   */
  queryParams: TQueryParams;

  /**
   * An arbitrary value associated with this location.
   */
  state: any;

  /**
   * A unique string associated with this location. On the initial location, this will be the string default.
   * On all subsequent locations, this string will be a unique identifier.
   */
  key: string;
}

export interface INavigateOptions {
  replace?: boolean;
  state?: any;
}

/**************************************************************************************************
 * Queries                                                                                        *
 **************************************************************************************************/

type IQueryResultFormat = typeof constants.queryResultFormats[number];

export interface IQueryExecutionOptions {
  variables: Record<string, any>;
  format: IQueryResultFormat;
}

/**************************************************************************************************
 * Context                                                                                        *
 **************************************************************************************************/

export interface IHyperContext<S> {
  readonly location: ILocation;

  readonly state: Record<string, S[keyof S]>;

  readonly refs: Record<string, any>;

  navigate: (target: TNavigationTarget, options?: INavigateOptions) => void;

  setQueryParams: (
    queryParams: TUpdateQueryParams,
    options?: INavigateOptions
  ) => void;

  setState: {
    (state: Partial<S>): void;
    (name: string, value: S[keyof S]): void;
  };

  inflate: (name: string, patches?: Record<string, IPatch>) => INode;

  runQuery: (
    name: string,
    options?: Partial<IQueryExecutionOptions>
  ) => Promise<any>;
}

export interface IHyperController<T> {
  init?: (context: IHyperContext<T>) => void;
  render?: (context: IHyperContext<T>) => INode;
}

/**************************************************************************************************
 * Events                                                                                         *
 **************************************************************************************************/

/**
 * @param C The type of the current target for this event.
 * @param T The type of the target for this event.
 */
export interface ISyntheticEvent<T> {
  target: T;
  createdAt: number;
  type: string;

  preventDefault: () => void;
  stopPropogation: () => void;
}

export type TModifierKey = typeof constants.modifierKeys[number];

export interface IMouseEvent<T> extends ISyntheticEvent<T> {
  altKey: boolean;
  ctrlKey: boolean;
  metaKey: boolean;
  shiftKey: boolean;

  button: number;
  buttons: number;

  clientX: number;
  clientY: number;
  movementX: number;
  movementY: number;
  pageX: number;
  pageY: number;
  screenX: number;
  screenY: number;

  getModifierState(key: TModifierKey): boolean;
}

type TPointerType = "mouse" | "pen" | "touch";

export interface IPointerEvent<T> extends IMouseEvent<T> {
  pointerId: number;
  pressure: number;
  tangentialPressure: number;
  tiltX: number;
  tiltY: number;
  twist: number;
  width: number;
  height: number;
  pointerType: TPointerType;
  primary: boolean;
}

/**************************************************************************************************
 * Event Handler                                                                                  *
 **************************************************************************************************/

export type TEventHandler<T, E extends ISyntheticEvent<T>> = {
  bivarianceHack: (event: E) => void;
}["bivarianceHack"];

export type TMouseEventHandler<T> = TEventHandler<T, IMouseEvent<T>>;

export type TPointerEventHandler<T> = TEventHandler<T, IPointerEvent<T>>;
