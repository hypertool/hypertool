import { constants } from "../utils";

export interface IController {
  id: string;
  name: string;
  description: string;
  language: string;
  patched: string;
  status: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface IScreen {
  id: string;
  app: IApp;
  name: string;
  title: string;
  description: string;
  slug: string;
  content: string;
  controller: IController;
  status: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface IApp {
  id: string;
  name: string;
  title: string;
  slug: string;
  description: string;
  screens: IScreen[];
  status: string;
  createdAt: Date;
  updatedAt: Date;
}

export type TAppContext = IApp;

export interface ICraftNode {
  custom: {
    [key: string]: any;
  };
  nodes: string[];
  props: {
    [key: string]: any;
  };
  type: {
    resolvedName: string;
  };
  parent?: string;
}

export type TCraftNodeKey = keyof ICraftNode;

export type TBasicNodeType = "View" | "Fragment" | "Text";

export interface ISymbolReference {
  moduleId: string;
  target: string;
}

export type TSymbolReferenceOrFunction = ISymbolReference | Function;

export type TPropertyValue =
  | number
  | boolean
  | string
  | null
  | object
  | ISymbolReference
  | undefined;

export interface IComponentProps extends Record<string, TPropertyValue> {
  id?: string;
}

export interface INode {
  /**
   * Each node has two identifiers: `node.internalId` and `node.props.id`.
   *
   * `node.internalId`:
   * It helps in internal bookkeeping of the nodes. It is mandatory, automatically
   * generated by CraftJS, and guaranteed to be unique across the screen.
   *
   * `node.props.id`:
   * It helps controllers select and apply actions on nodes. It is optional,
   * and assigned by the developer.
   *
   * Hypertool does not guarantee the prop ID to be unique across the screen.
   * It is the responsibility of the user to ensure the uniqueness.
   * App builder and generic host neither produce errors nor warnings for
   * duplicate prop IDs.
   */
  internalId: string;
  type: string | TBasicNodeType;
  children: INode[];
  props: IComponentProps;
  __hyperNode: true;
}

export type TPatchEntry =
  | Record<string, TPropertyValue>
  | INode
  | TTransformNodeFunction;

export interface IPatch {
  [key: string]: TPatchEntry;
}

export interface IPath {
  /**
   * The path component in the URL, beginning with a `/`.
   */
  path: string;

  /**
   * The query string component in the URL, beginning with a `?`.
   */
  query: string;

  /**
   * A URL fragment identifier, beginning with a `#`.
   */
  hash: string;
}

/**
 * Describes a location that is the destination of some navigation.
 * It can either be a URL or pieces of a URL.
 */
export type TNavigationTarget = string | Partial<IPath>;

export type TQueryParams = Record<string, string | string[]>;

export type TQueryParamPair = [string, string];

export type TUpdateQueryParams =
  | string // "foo=bar&foo=soap"
  | TQueryParamPair[] // [["foo", "bar"], ["foo", "soap"]]
  | TQueryParams; // { foo: ["bar", "soap"] }

export interface ILocation extends IPath {
  /**
   * An object containing the decoded dynamic parameters from the
   * path component in the URL.
   */
  pathParams: Record<string, string | undefined>;

  /**
   * An object containing the decoded query parameters contained
   * in the URL.
   */
  queryParams: TQueryParams;

  /**
   * An arbitrary value associated with this location.
   */
  state: any;

  /**
   * A unique string associated with this location. On the initial location, this will be the string default.
   * On all subsequent locations, this string will be a unique identifier.
   */
  key: string;
}

export interface INavigateOptions {
  replace?: boolean;
  state?: any;
}

/**************************************************************************************************
 * Queries                                                                                        *
 **************************************************************************************************/

export type TQueryResultFormat = typeof constants.queryResultFormats[number];

interface IQueryResult {
  error: any;
  data: any;
}

/**************************************************************************************************
 * Context                                                                                        *
 **************************************************************************************************/

export interface TNavigateFunction {
  (target: TNavigationTarget, options?: INavigateOptions): void;
  (delta: number): void;
}

export type TMapCallbackFunction<T> = {
  bivarianceHack: (item: T) => Record<string, IPatch>;
}["bivarianceHack"];

export type TTransformNodeFunction = (template: INode) => INode;

export interface IHyperContext<S> {
  readonly location: ILocation;

  readonly state: Record<string, S[keyof S]>;

  readonly refs: Record<string, any>;

  navigate: TNavigateFunction;

  setQueryParams: (
    queryParams: TUpdateQueryParams,
    options?: INavigateOptions
  ) => void;

  setState: {
    (state: Partial<S>): void;
    (name: string, value: S[keyof S]): void;
  };

  applyPatches: (node: INode, patches: Record<string, IPatch>) => INode;

  inflate: (name: string, patches?: Record<string, IPatch>) => INode;

  /**
   * Rendering a list of items is a very common operation. For example, let's take an image
   * with a caption. The list can be represented as:
   *
   * ```
   * <list>
   *   <item>
   *     <image />
   *     <caption />
   *   </item>
   *   <item>
   *     <image />
   *     <caption />
   *   </item>
   * </list>
   * ```
   *
   * To add more items, we simply need to duplicate the `<item>` element. The same idea
   * is adopted in Hypertool. In other words, we design a single item and then duplicate
   * the item to represent a list of items.
   *
   * There are two ways of implementing this:
   * 1. Array of inflated fragments
   * 2. Array of nodes, derived from a template node
   *
   * The `map` function implements the second strategy. Basically, it takes a template
   * node and creates multiple copies of it by applying modifications provided by the
   * callback.
   *
   * For example,
   * ```
   * {
   *     user: context.map(users,
   *         (user) => ({
   *             firstName: {
   *                 text: user.firstName,
   *             },
   *             lastName: {
   *                 text: user.lastName,
   *             }
   *          })
   *    )
   * }
   * ```
   */
  map: <T>(
    items: T[],
    callback: TMapCallbackFunction<T>
  ) => TTransformNodeFunction[];

  query: (
    name: string,
    variables?: Record<string, any> | any[],
    format?: TQueryResultFormat
  ) => Promise<IQueryResult>;
}

export interface IHyperController<T> {
  init?: (context: IHyperContext<T>) => void;
  render?: (context: IHyperContext<T>) => INode;
}

/**************************************************************************************************
 * Events                                                                                         *
 **************************************************************************************************/

/**
 * @param C The type of the current target for this event.
 * @param T The type of the target for this event.
 */
export interface ISyntheticEvent<T> {
  target: T;
  createdAt: number;
  type: string;

  preventDefault: () => void;
  stopPropogation: () => void;
}

export type TModifierKey = typeof constants.modifierKeys[number];

export interface IMouseEvent<T> extends ISyntheticEvent<T> {
  altKey: boolean;
  ctrlKey: boolean;
  metaKey: boolean;
  shiftKey: boolean;

  button: number;
  buttons: number;

  clientX: number;
  clientY: number;
  movementX: number;
  movementY: number;
  pageX: number;
  pageY: number;
  screenX: number;
  screenY: number;

  getModifierState(key: TModifierKey): boolean;
}

type TPointerType = "mouse" | "pen" | "touch";

export interface IPointerEvent<T> extends IMouseEvent<T> {
  pointerId: number;
  pressure: number;
  tangentialPressure: number;
  tiltX: number;
  tiltY: number;
  twist: number;
  width: number;
  height: number;
  pointerType: TPointerType;
  primary: boolean;
}

/**************************************************************************************************
 * Event Handler                                                                                  *
 **************************************************************************************************/

export type TEventHandler<T, E extends ISyntheticEvent<T>> = {
  bivarianceHack: (event: E) => void;
}["bivarianceHack"];

export type TMouseEventHandler<T> = TEventHandler<T, IMouseEvent<T>>;

export type TPointerEventHandler<T> = TEventHandler<T, IPointerEvent<T>>;
